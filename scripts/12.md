不一定能。关键在于 浏览器发出的请求头里有没有带 Origin：
	•	跨站点 (cross-site)
→ 浏览器一定会带 Origin，所以后端可以直接取到。
	•	同站点 (same-site) + GET/HEAD 这类“简单方法”
→ 浏览器通常省略 Origin，这时后端拿不到。
	•	同站点 + POST/PUT/DELETE 这类“非简单方法”
→ 浏览器仍然会带 Origin，后端能拿到。

⸻

怎么验证

你可以在浏览器 DevTools 的 Network 面板里点开 GET 请求 → Request Headers。如果看不到 Origin: xxx，说明后端自然也拿不到。

⸻

如果 GET 没有 Origin，后端能拿什么？

常见可用的请求头有：
	•	Sec-Fetch-Site（标明 same-site / cross-site）
	•	Referer（大多数 GET 会带，但部分隐私场景可能被裁掉或为空）
	•	Host（请求的目标域名）
	•	Sec-Fetch-Mode、Sec-Fetch-Dest（辅助信息）

⸻

👉 也就是说，方案 A 下后端能否取到 Origin，取决于浏览器是否在 GET 请求里发送。
	•	如果浏览器省略了，就拿不到，需要依赖其他头（Sec-Fetch-Site / Referer）。
	•	如果是 POST/跨站 GET，就一定能拿到。

要不要我帮你写一段 Node.js/Express 或 Java/Spring 的示例代码，展示后端怎么同时兼容 Origin / Sec-Fetch-* / Referer 这些头来判断来源？