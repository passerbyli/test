好的！下面给你一份可直接运行的 Node.js 脚本，用 exceljs 读取“权限矩阵”Excel，按规则校验单元格；凡是错误值，给单元格填充浅红色背景，并在最后新增“错误清单”工作表列出详细问题；最后另存为新文件。

你只需把校验规则在 rules 里按列名或列索引配置即可。

⸻

1) 安装依赖

npm init -y
npm i exceljs


⸻

2) 目录结构（示例）

.
├─ input.xlsx            # 待校验的权限矩阵
├─ validate-permission-matrix.js
└─ package.json


⸻

3) 脚本：validate-permission-matrix.js

// validate-permission-matrix.js
// 用 exceljs 校验权限矩阵：错误单元格标红，并导出新文件 + 错误清单

const path = require('path');
const ExcelJS = require('exceljs');

/**
 * 你可以在这里配置你的校验规则。
 * 支持两种方式：
 *  - byHeader: 以表头（列名）识别列并校验
 *  - byIndex: 以列索引（1 开始）识别列并校验
 *
 * 校验器函数签名： (value, {row, col, header}) => { ok: boolean, reason?: string, normalized?: any }
 *  - ok=false 表示该单元格错误
 *  - reason 为错误原因（会记录到“错误清单”sheet）
 *  - normalized（可选）表示你想把原值规范化回写（比如 'y' -> 'Y'）
 */
const rules = {
  // 方式一：按表头名称（header 文本完全匹配）
  byHeader: {
    '角色': nonEmpty('角色不可为空'),
    '用户': nonEmpty('用户不可为空'),

    // 典型：权限列只允许 Y/N（同时兼容 1/0/true/false/是/否 等，并规范化为 Y/N）
    '读': yesNo({ allowBool: true, allow10: true, allowZh: true }),
    '写': yesNo({ allowBool: true, allow10: true, allowZh: true }),
    '删': yesNo({ allowBool: true, allow10: true, allowZh: true }),

    // 示例：也可以用正则限定可选值，如“环境”只能是 dev/test/prod
    '环境': regex(/^(dev|test|prod)$/i, '环境必须是 dev/test/prod'),
  },

  // 方式二：按列索引（1 起）
  byIndex: {
    // 例如第 1 列必须非空：
    // 1: nonEmpty('第1列不可为空'),
  },

  // 如果你的权限矩阵的权限列非常多且有命名规律（如以 “_读/_写/_删” 结尾），
  // 可以在这里追加一个动态匹配器（可按需启用）
  dynamicMatchers: [
    {
      // 匹配所有以 "_读"、"_写"、"_删" 结尾的列
      test: (header) => /(_读|_写|_删)$/i.test(header || ''),
      validator: yesNo({ allowBool: true, allow10: true, allowZh: true })
    }
  ]
};

/** ========== 内置校验器 ========== **/

function nonEmpty(reason = '不可为空') {
  return (v) => {
    const ok = !(v === null || v === undefined || String(v).trim() === '');
    return ok ? { ok } : { ok: false, reason };
  };
}

// 统一把各种“真/假”映射为 'Y' / 'N'
function yesNo(opts = {}) {
  const { allowBool = true, allow10 = true, allowZh = true } = opts;
  const truthy = ['y', 'yes', 'true', 't'];
  const falsy = ['n', 'no', 'false', 'f'];

  return (v) => {
    if (v === null || v === undefined || String(v).trim() === '') {
      return { ok: false, reason: '不能为空（仅允许 Y/N）' };
    }

    let s = String(v).trim().toLowerCase();

    if (allowZh) {
      if (s === '是') s = 'y';
      if (s === '否') s = 'n';
    }
    if (allow10) {
      if (s === '1') s = 'y';
      if (s === '0') s = 'n';
    }
    if (allowBool) {
      if (s === 'true') s = 'y';
      if (s === 'false') s = 'n';
    }

    if (truthy.includes(s)) return { ok: true, normalized: 'Y' };
    if (falsy.includes(s)) return { ok: true, normalized: 'N' };

    return { ok: false, reason: '仅允许 Y/N（兼容：1/0、true/false、是/否）' };
  };
}

function regex(re, reason = '值不符合格式要求') {
  return (v) => {
    if (v === null || v === undefined) return { ok: false, reason };
    const s = String(v).trim();
    return re.test(s) ? { ok: true } : { ok: false, reason };
  };
}

/** ========== 工具：设置单元格浅红背景 & 可选边框 ========== **/
function paintBadCell(cell) {
  cell.fill = {
    type: 'pattern',
    pattern: 'solid',
    // Excel 常见浅红（与“数据有效性-错误”接近）
    fgColor: { argb: 'FFFFC7CE' }, // 浅红底
    bgColor: { argb: 'FFFFC7CE' }
  };
  // 可选：边框
  cell.border = {
    top: { style: 'thin' },
    left: { style: 'thin' },
    bottom: { style: 'thin' },
    right: { style: 'thin' }
  };
}

/** ========== 主流程 ========== **/
async function main() {
  // 你可以用命令行参数替换这两个路径
  const inputPath = process.argv[2] || path.resolve(__dirname, 'input.xlsx');
  const outputPath = process.argv[3] || path.resolve(__dirname, 'output_checked.xlsx');

  const workbook = new ExcelJS.Workbook();
  await workbook.xlsx.readFile(inputPath);

  // 默认处理第一个工作表（可按需循环所有 sheet）
  const sheet = workbook.worksheets[0];
  if (!sheet) {
    console.error('未找到工作表，请检查文件。');
    process.exit(1);
  }

  // 假设第 1 行是表头（header row）
  const headerRowNumber = 1;
  const headerRow = sheet.getRow(headerRowNumber);
  const headers = headerRow.values.map((v) => (typeof v === 'object' && v?.text) ? v.text : v); // 兼容富文本
  // ExcelJS 的 Row.values 从索引 1 开始，索引 0 通常是 undefined

  // 错误集合
  const errors = [];

  // 从第 2 行开始校验
  for (let r = headerRowNumber + 1; r <= sheet.rowCount; r++) {
    const row = sheet.getRow(r);
    // 跳过完全空行
    if (rowIsEmpty(row)) continue;

    for (let c = 1; c <= sheet.columnCount; c++) {
      const cell = row.getCell(c);
      const raw = cell.value;
      const header = (headers && headers[c]) ? String(headers[c]).trim() : '';

      // 找到该列应使用的校验器（优先按表头，其次按列索引，最后动态匹配）
      const validator =
        (header && rules.byHeader[header]) ||
        rules.byIndex[c] ||
        getDynamicValidator(header);

      if (!validator) continue; // 没有规则则跳过

      const { ok, reason, normalized } = safeRunValidator(validator, raw, { row: r, col: c, header });

      if (!ok) {
        // 标红
        paintBadCell(cell);
        // 记录错误
        errors.push({
          row: r,
          col: c,
          address: cell.address,
          header,
          value: formatCellValue(raw),
          reason: reason || '不符合校验规则'
        });
      } else if (normalized !== undefined && normalized !== raw) {
        // 把允许的等价值做标准化（如 y/1/是 => Y）
        cell.value = normalized;
      }
    }
  }

  // 写入“错误清单”sheet
  appendErrorSheet(workbook, errors);

  await workbook.xlsx.writeFile(outputPath);

  console.log(`✅ 校验完成：共发现 ${errors.length} 处问题。已导出：${outputPath}`);
}

/** ========== 辅助函数 ========== **/

function rowIsEmpty(row) {
  for (let c = 1; c <= row.cellCount; c++) {
    const v = row.getCell(c).value;
    if (v !== null && v !== undefined && String(v).trim() !== '') return false;
  }
  return true;
}

function getDynamicValidator(header) {
  if (!rules.dynamicMatchers || !header) return null;
  for (const m of rules.dynamicMatchers) {
    try {
      if (m?.test?.(header)) return m.validator;
    } catch (_) {}
  }
  return null;
}

function safeRunValidator(validator, value, ctx) {
  try {
    return validator(value, ctx) || { ok: true };
  } catch (e) {
    return { ok: false, reason: `校验器异常：${e.message || e}` };
  }
}

function formatCellValue(v) {
  if (v == null) return '';
  if (typeof v === 'object') {
    // 处理富文本/公式/日期等情况
    if (v.text) return String(v.text);
    if (v.result !== undefined) return String(v.result);
    if (v.richText) return v.richText.map(t => t.text).join('');
    if (v instanceof Date) return v.toISOString();
    try { return JSON.stringify(v); } catch { return String(v); }
  }
  return String(v);
}

function appendErrorSheet(workbook, errors) {
  // 删除已存在的同名工作表，避免多次运行叠加
  const exist = workbook.getWorksheet('错误清单');
  if (exist) workbook.removeWorksheet(exist.id);

  const ws = workbook.addWorksheet('错误清单');
  ws.columns = [
    { header: '序号', key: 'idx', width: 8 },
    { header: '位置', key: 'address', width: 12 },
    { header: '行号', key: 'row', width: 8 },
    { header: '列号', key: 'col', width: 8 },
    { header: '表头', key: 'header', width: 20 },
    { header: '原值', key: 'value', width: 24 },
    { header: '原因', key: 'reason', width: 40 },
  ];

  errors.forEach((e, i) => {
    ws.addRow({
      idx: i + 1,
      address: e.address,
      row: e.row,
      col: e.col,
      header: e.header,
      value: e.value,
      reason: e.reason
    });
  });

  // 简单设置表头加粗
  const headerRow = ws.getRow(1);
  headerRow.font = { bold: true };
  headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
}

if (require.main === module) {
  main().catch((err) => {
    console.error('❌ 处理失败：', err);
    process.exit(1);
  });
}


⸻

4) 运行

node validate-permission-matrix.js ./input.xlsx ./output_checked.xlsx
# 若省略参数，默认读取 ./input.xlsx，输出 ./output_checked.xlsx


⸻

规则写法说明（按需改动）
	•	按表头：将你的权限列名（如 “读/写/删/环境/角色/用户” 等）写进 rules.byHeader。
	•	按列号：如果你的表没有表头，或表头不稳定，可用 rules.byIndex，以 1 起始的列索引配置。
	•	批量匹配：如果有大量权限列有相同规则，比如都以 _读/_写/_删 结尾，可用 dynamicMatchers 统一处理。
	•	自定义校验：写一个函数 (value, ctx) => ({ ok, reason, normalized })，返回 ok=false 即判错；可返回 normalized 来“矫正”合法值（如 y → Y）。

⸻

常见问题
	•	已合并单元格如何处理？
exceljs 读取合并单元格时，值通常在合并区域的起始单元格。如你的矩阵使用合并行/列做分组，建议优先对实际存值的单元格做校验。若需要对合并范围内每格都标色，可在发现错误时对 sheet.getCell(address) 遍历该合并区域的地址批量上色。
	•	单元格加入批注/备注？
需要备注可将 cell.note = e.reason（exceljs 支持注释），或只在“错误清单”表中汇总显示（上面的脚本已做汇总）。
	•	不想修改原文件
本脚本默认另存为 output_checked.xlsx，不会覆盖原文件。

⸻

如果你把一小段真实的表头和几列示例规则发我，我可以直接把 rules 预置好，帮你对接你现有的表结构。